# Copilot Instructions for Agora

## Project Summary

Agora is a coordination protocol for AI agents built on peer-to-peer signed messaging. It's NOT a social network or chat platform — it's a **synchronization layer** for structured state, capability discovery, and coordination between agents.

**Core Concepts:**
- **Ed25519 cryptographic identity**: Agents are identified by their keypair, no registration needed
- **Signed envelopes**: Every message is content-addressed and cryptographically signed
- **Peer registry**: Named peers with capability discovery
- **HTTP webhook transport**: Works between any instances that speak HTTP
- **CLI**: Complete command-line interface for all operations

Think "Git + DNS + pub/sub" for agent coordination, not "Twitter + Reddit" for social interaction.

## Languages & Frameworks

- **Language**: TypeScript
- **Runtime**: Node.js 22.x
- **Module System**: ES modules (type: "module" in package.json)
- **Build Tool**: TypeScript Compiler (tsc)
- **Test Framework**: Node.js native test runner with tsx
- **Linter**: ESLint with TypeScript plugin

## Repository Structure

```
/home/runner/work/agora/agora/
├── src/                    # TypeScript source files
│   ├── cli.ts             # CLI entry point (bin: agora)
│   ├── index.ts           # Library entry point
│   ├── identity/          # Ed25519 keypair management
│   ├── message/           # Envelope and message types
│   ├── peer/              # Peer store and discovery
│   ├── registry/          # Capability messages (announce, discover)
│   └── transport/         # HTTP transport and peer config
├── test/                  # Test files (*.test.ts)
├── dist/                  # Compiled JavaScript (generated by build)
├── .github/
│   └── workflows/
│       ├── ci.yml         # Lint, build, test on PR/push
│       └── release.yml    # Publish to npm on version tags
├── package.json           # npm package config
├── tsconfig.json          # TypeScript configuration
├── eslint.config.js       # ESLint configuration
├── README.md              # User-facing documentation
├── DESIGN.md              # Architecture and design decisions
├── CONTRIBUTING.md        # Contribution guidelines
└── SECURITY.md            # Security considerations
```

## Build, Test, and Lint Commands

**ALWAYS run commands from the repository root: `/home/runner/work/agora/agora`**

### Install Dependencies
```bash
npm ci
```
- Use `npm ci` (not `npm install`) for reproducible builds
- Required before any build/test/lint operations
- Takes ~3-5 seconds

### Lint
```bash
npm run lint
```
- Runs ESLint on `src` and `test` directories
- Checks for TypeScript-specific issues
- Must pass before commits are accepted
- Takes ~1-2 seconds

### Build
```bash
npm run build
```
- Compiles TypeScript to JavaScript in `dist/` directory
- Generates type declarations (.d.ts files)
- Must succeed before publishing
- Takes ~1-2 seconds

### Test
```bash
npm test
```
- Runs all tests in `test/*.test.ts`
- Uses Node.js native test runner with tsx for TypeScript
- Tests include: CLI, envelope signing/verification, keypair, peer transport, HTTP transport
- All 168 tests must pass
- Takes ~5-6 seconds

### Pre-publish Check
```bash
npm run prepublishOnly
```
- Runs lint, build, and test in sequence
- This is what CI runs and what happens before npm publish
- Takes ~10-15 seconds total

### CLI Testing (after build)
```bash
# Test CLI commands (requires build first)
node dist/cli.js init --config /tmp/test-config.json
node dist/cli.js whoami --config /tmp/test-config.json
node dist/cli.js status --config /tmp/test-config.json
```

## CI Workflows

### CI Workflow (.github/workflows/ci.yml)
**Triggers**: Push to `main` or pull requests targeting `main`

**Steps**:
1. Checkout code
2. Setup Node.js 22.x with npm cache
3. Run `npm ci`
4. Run `npm run lint`
5. Run `npm run build`
6. Run `npm test`

**If CI fails**: Check the failed step (lint/build/test) and fix locally before pushing

### Release Workflow (.github/workflows/release.yml)
**Triggers**: Push of version tags (e.g., `v0.1.2`)

**Steps**:
1. Same as CI workflow (lint, build, test)
2. Publish to npm with `--access public`

**Note**: Uses `NPM_TOKEN` secret for authentication

## CLI Commands Reference

The CLI is built as a single executable at `dist/cli.js` (available as `agora` when installed).

### Identity Management

**`agora init`**
- Generates new ed25519 keypair and saves to config
- Config location: `~/.config/agora/config.json` (override with `--config` or `AGORA_CONFIG`)
- Safe to run multiple times (won't overwrite existing config)

**`agora whoami`**
- Displays your public key and config file path
- Requires existing config file

**`agora status`**
- Shows node status: identity, peer count, list of configured peers
- Requires existing config file

### Peer Management

**`agora peers`**
- Lists all configured peers
- Output includes name, URL, token, and public key

**`agora peers add <name> --url <url> --token <token> --pubkey <pubkey>`**
- Adds a new peer to config
- All flags are required
- Example: `agora peers add bishop --url http://localhost:18790/hooks --token abc123 --pubkey <hex-pubkey>`

**`agora peers remove <name>`**
- Removes peer from config
- Errors if peer doesn't exist

### Messaging

**`agora announce [--name <name>] [--version <version>]`**
- Broadcasts an announce message to all configured peers
- Optional name and version (defaults to agent identity)
- Requires at least one peer configured

**`agora send <peer> <message>`**
- Sends text message to a specific peer
- Peer must be configured in peer registry

**`agora send <peer> --type <type> --payload <json>`**
- Sends typed message with JSON payload
- Example: `agora send bishop --type task --payload '{"action":"summarize"}'`

**`agora decode <envelope>`**
- Decodes and verifies an inbound envelope
- Envelope format: `[AGORA_ENVELOPE]<base64-json>`
- Verifies signature and returns payload

### Global Options

**`--config <path>`**: Use custom config file instead of default
**`--pretty`**: Output in human-readable format instead of JSON

### Testing CLI Commands

1. Build first: `npm run build`
2. Use temp config for testing: `--config /tmp/test-agora-config.json`
3. Test sequence:
   ```bash
   node dist/cli.js init --config /tmp/test.json
   node dist/cli.js whoami --config /tmp/test.json
   node dist/cli.js status --config /tmp/test.json
   node dist/cli.js peers --config /tmp/test.json
   ```
4. Clean up: `rm /tmp/test.json`

## Common Issues & Troubleshooting

### "Cannot find module" errors
- **Cause**: Build not run or stale dist/ directory
- **Fix**: Run `npm run build`

### Test failures
- **Cause**: Usually indicates a real bug or breaking change
- **Fix**: Investigate the specific test failure; don't skip tests

### Lint errors
- **Common issues**:
  - Unused variables (use `_` prefix for intentionally unused vars)
  - Missing return types (add explicit return types to functions)
  - Using `any` type (prefer specific types)
- **Fix**: Address the specific ESLint errors reported

### CLI returns "Unknown command"
- **Cause**: Invalid command or subcommand
- **Fix**: Check command syntax against this guide or README.md

### "Config file not found" errors
- **Cause**: Config not initialized
- **Fix**: Run `agora init` first

### Import/export errors
- **Cause**: This is an ES module project
- **Important**:
  - All imports must include `.js` extension (even for .ts files): `import { foo } from './bar.js'`
  - Use `import` not `require`
  - `package.json` has `"type": "module"`

## Making Changes

### Adding New Message Types
1. Define type in `src/message/types/` (see `paper-discovery.ts` as example)
2. Add validation function
3. Export from `src/index.ts`
4. Add tests in `test/`
5. Update README.md with message type documentation

### Adding New CLI Commands
1. Add command handler in `src/cli.ts`
2. Update usage text/error messages
3. Add tests in `test/cli.test.ts`
4. Update README.md CLI section
5. Test manually with temp config file

### Modifying Transport Layer
1. Changes in `src/transport/`
2. Update tests in `test/peer-transport.test.ts` and `test/transport-http.test.ts`
3. Consider backward compatibility with existing peers
4. Update SECURITY.md if crypto/signature logic changes

## Code Style & Conventions

- **Explicit return types**: Functions should have explicit return type annotations
- **No `any` types**: Use specific types or `unknown` when type is truly unknown
- **Unused variables**: Prefix with `_` if intentionally unused
- **Import paths**: Always use `.js` extension in imports (even for `.ts` files)
- **Error handling**: Return error objects from functions, don't throw (see CLI patterns)
- **Naming**: camelCase for variables/functions, PascalCase for types/interfaces
- **File structure**: One main export per file, collocate types with implementations

## Security Considerations

- All messages must be cryptographically signed (ed25519)
- Envelope verification is mandatory before processing messages
- No unsigned messages should ever be processed
- Config files may contain private keys - never commit them
- See SECURITY.md for detailed security architecture

## Testing Strategy

- **Unit tests**: Individual functions (keypair, envelope, messages)
- **Integration tests**: Multi-component flows (peer transport, CLI)
- **No mocking of crypto**: Real ed25519 operations in tests
- **Temp files**: Tests use `/tmp/` for config files, clean up after
- **Deterministic**: Tests should not depend on timing or external services

## Pre-Commit Checklist

Before committing changes:
1. ✅ `npm run lint` passes
2. ✅ `npm run build` succeeds
3. ✅ `npm test` all tests pass
4. ✅ Manual CLI testing for CLI changes
5. ✅ Updated documentation if APIs changed
6. ✅ No secrets or private keys in commits

## Additional Resources

- **README.md**: User-facing documentation and CLI guide
- **DESIGN.md**: Architecture, design decisions, and future vision
- **CONTRIBUTING.md**: Contribution guidelines and code of conduct
- **SECURITY.md**: Security architecture and threat model
- **package.json**: Build scripts, dependencies, package metadata
